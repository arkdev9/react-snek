{"version":3,"sources":["Board.js","App.jsx","serviceWorker.js","index.js"],"names":["Snek","this","positions","y","x","newPos","grid","direction","length","checkValidPos","collison","collisionInfo","food","snek","newPositions","slice","push","collision","Board","snekDir","dirMap","37","38","39","40","newrow","TICK","moved","moveSnek","endGame","rXIdx","Math","floor","random","rYIdx","why","console","trace","alert","clearInterval","gameLoop","e","keyCode","log","App","props","board","state","ticker","getTicker","setInterval","newTick","updateTicker","setState","clearTicker","document","addEventListener","handleKey","className","map","row","i","key","sqr","j","React","Component","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.b52b6637.chunk.js","sourcesContent":["var boardDim = 30;\n\nclass Snek {\n  constructor() {\n    this.positions = [\n      {\n        y: 0,\n        x: 0,\n      },\n    ];\n  }\n\n  checkValidPos(newPos, grid) {\n    if (newPos.x >= boardDim || newPos.x < 0) return false;\n    if (newPos.y >= boardDim || newPos.y < 0) return false;\n    return true;\n  }\n\n  moveSnek(direction, grid) {\n    // Make the first element in positions null\n    let newPos = {};\n    if (direction === \"right\") {\n      newPos = {\n        y: this.positions[this.positions.length - 1].y,\n        x: this.positions[this.positions.length - 1].x + 1,\n      };\n    }\n    if (direction === \"left\") {\n      newPos = {\n        y: this.positions[this.positions.length - 1].y,\n        x: this.positions[this.positions.length - 1].x - 1,\n      };\n    }\n    if (direction === \"up\") {\n      newPos = {\n        y: this.positions[this.positions.length - 1].y - 1,\n        x: this.positions[this.positions.length - 1].x,\n      };\n    }\n    if (direction === \"down\") {\n      newPos = {\n        y: this.positions[this.positions.length - 1].y + 1,\n        x: this.positions[this.positions.length - 1].x,\n      };\n    }\n\n    // Check out of bounds\n    let validMove = this.checkValidPos(newPos);\n    if (!validMove)\n      return {\n        collison: \"bounds\",\n        grid: grid,\n      };\n\n    // Check collisions\n    let collisionInfo = \"none\";\n    if (grid[newPos.y][newPos.x].food) {\n      collisionInfo = \"food\";\n    }\n    if (grid[newPos.y][newPos.x].snek) {\n      collisionInfo = \"snek\";\n    }\n\n    // If not moved into food, remove last snek block from grid\n    if (collisionInfo === \"none\") {\n      // Remove prev snek position from grid\n      grid[this.positions[0].y][this.positions[0].x].snek = false;\n    } else if (collisionInfo === \"food\") {\n      grid[newPos.y][newPos.x].food = false;\n    }\n    // If moved into food, keep the last snek block, else remove it from new positions\n    let newPositions = this.positions.slice(\n      collisionInfo === \"food\" ? 0 : 1,\n      this.positions.length\n    );\n\n    // Register new positions\n    newPositions.push(newPos);\n    this.positions = newPositions;\n\n    // Update new position on grid\n    grid[newPos.y][newPos.x].snek = true;\n\n    return {\n      collision: collisionInfo,\n      grid: grid,\n    };\n  }\n}\n\nclass Board {\n  constructor() {\n    this.grid = [];\n    this.snek = new Snek();\n    this.snekDir = \"right\";\n    this.dirMap = { 37: \"left\", 38: \"up\", 39: \"right\", 40: \"down\" };\n    // Get a fresh board\n    for (let y = 0; y < boardDim; y++) {\n      let newrow = [];\n      for (let x = 0; x < boardDim; x++) {\n        newrow.push({\n          snek: false,\n          food: false,\n        });\n      }\n      this.grid.push(newrow);\n    }\n    // Initial snek position set manually on the grid\n    this.grid[this.snek.positions[0].y][this.snek.positions[0].x].snek = true;\n    // Some food to start off\n    this.grid[7][8].food = true;\n  }\n\n  gameLoop(TICK) {\n    const moved = this.snek.moveSnek(this.snekDir, this.grid);\n    if (moved.collision === \"bounds\") {\n      this.endGame(moved.collision);\n      return false;\n    }\n    if (moved.collision === \"snek\") {\n      // out bounds or moved into self, stop ticker\n      this.endGame(moved.collision);\n      return false;\n    }\n    if (moved.collision === \"food\") {\n      // Add a nother random food onto the grid\n      // Make sure the food doesn't fall on an existing snek block\n      // Pick a random index, pick the first free block iterating through\n      // all the grid. If no free block, end game\n      let rXIdx = Math.floor(Math.random() * boardDim);\n      let rYIdx = Math.floor(Math.random() * boardDim);\n      for (let y = rYIdx; y !== rYIdx - 1; y++) {\n        for (let x = rXIdx; x !== rXIdx - 1; x++) {\n          if (!this.grid[y][x].snek) {\n            this.grid[y][x].food = true;\n            return TICK * 0.7;\n          }\n        }\n      }\n\n      // If didn't return yet\n      this.endGame(\"Full grid\");\n      return false;\n    }\n    return TICK;\n  }\n\n  endGame(why) {\n    console.trace();\n    alert(`Game Over: ${why}`);\n    clearInterval(this.gameLoop);\n  }\n\n  handleKey(e) {\n    if (e.keyCode in this.dirMap) {\n      console.log(`Clicked: ${e.keyCode} - ${this.dirMap[e.keyCode]}`);\n      this.snekDir = this.dirMap[e.keyCode];\n    }\n  }\n}\n\nexport default Board;\n","import React from \"react\";\n\nimport Board from \"./Board\";\nimport \"./App.css\";\n\n/*\n  left arrow\t37\n  up arrow\t38\n  right arrow\t39\n  down arrow\t40\n*/\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.TICK = 200;\n    this.board = new Board(this.TICK);\n    this.state = {\n      grid: this.board.grid,\n    };\n\n    this.ticker = this.getTicker(this.TICK);\n  }\n\n  getTicker() {\n    return setInterval(() => {\n      const newTick = this.board.gameLoop(this.TICK);\n      if (!newTick) {\n        this.clearTicker();\n        return;\n      }\n      if (newTick !== this.TICK) {\n        this.TICK = newTick;\n        this.updateTicker(this.TICK);\n      }\n      this.setState({\n        grid: this.board.grid,\n      });\n    }, this.TICK);\n  }\n\n  updateTicker(newTick) {\n    clearInterval(this.ticker);\n    this.ticker = this.getTicker(newTick);\n  }\n\n  clearTicker() {\n    clearInterval(this.ticker);\n  }\n\n  componentDidMount() {\n    document.addEventListener(\n      \"keydown\",\n      (e) => {\n        this.board.handleKey(e);\n      },\n      false\n    );\n  }\n\n  render() {\n    return (\n      <div className=\"container\">\n        <h1>Snek</h1>\n        <div className=\"game-container\">\n          {this.state.grid.map((row, i) => (\n            <div key={i} className=\"row\">\n              {row.map((sqr, j) => (\n                <div\n                  key={j}\n                  className={`square ${sqr.snek && \"snek\"} ${\n                    sqr.food && \"food\"\n                  }`}\n                />\n              ))}\n            </div>\n          ))}\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}